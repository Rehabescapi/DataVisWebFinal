<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js -->

<html>
  <head>
    <script src="https://d3js.org/d3.v4.min.js"></script> 
    <script type="text/javascript" src = "usstates.js"></script>
   
    <title>Geography</title>
    <style>
      svg {
        font: 10px sans-serif;
      }

      a:hover tspan:first-child {
        text-decoration: underline;
      }

      tspan:last-child {
        font-size: 9px;
        fill-opacity: 0.7;
      }
      .pan:hover rect,
 			.pan:hover text,
			.zoom:hover rect,
 			.zoom:hover text {
				fill: blue;
			}
    </style>

</head>
<body>
  <div id ="Graphs">
    <svg id="my_dataviz"></svg>
   
    <svg id="chicago">
      <g id="city">
       </g>
    </svg>
  </div>
    

    
    
    <script>


// The svg
      var width =1000;
      var height = 600;
    const svg = d3.select("svg").attr("width", width).attr("height", height);
   


  

// Map and projection
    
var projection = d3.geoAlbersUsa()
								   .translate([width/2, height/2]).scale([2000]);
    const path = d3.geoPath().projection(projection);
    
    //console.log(projection(40.71453,-74.00712))

    var color = d3.scaleQuantize()
								.range(["rgb(237,248,233)","rgb(186,228,179)","rgb(116,196,118)","rgb(49,163,84)","rgb(0,109,44)"]);
								//Colors derived from ColorBrewer, by Cynthia Brewer, and included in
								//https://github.com/d3/d3-scale-chromatic
    var formatAsThousands = d3.format(","); 


    var zooming = function(d) {
      
      var offset = [d3.event.transform.x, d3.event.transform.y];

      var newScale = d3.event.transform.k * 2000;

      projection.translate(offset).scale(newScale);

      svg.selectAll("path").attr("d",path);
      svg.selectAll("circle").attr("cx", function(d){
      return projection([d.lon,d.lat])[0];
    } ).attr("cy", function (d) {
      return projection([d.lon, d.lat])[1];
    });
    }
    var zoom = d3.zoom().on("zoom", zooming);
    var center = projection([-97.0, 39.0]);

    var map = svg.append("g")
      .attr("id", "map").call(zoom)
      .call(zoom.transform, d3.zoomIdentity.translate(width/2, height/2)
							.scale(0.25)
							.translate(-center[0], -center[1]));

    

    map.append("rect")
   .attr("x", 0)
   .attr("y", 0)
   .attr("width", width)
   .attr("height", height)
   .attr("opacity", 0);
                
    d3.csv("./us-ag-productivity.csv", function(data) {

      //Set input domain for color scale
      color.domain([
        d3.min(data, function(d) { return d.value; }), 
        d3.max(data, function(d) { return d.value; })
      ]);
   

  
// Load external data and boot

       
      //Note to Jason -- Just start running things on http-server
        d3.json("./chicago_zipcodes.json", function(json) {
          for(var i = 0; i < data.arcs.length; i++)
          {
            var dataState = data.arcs[i].state;
            var dataValue = parseFloat(data[i].value);
            for (var j = 0; j < json.features.length; j++) {
      
              var jsonState = json.features[j].properties.name;
        
              if (dataState == jsonState) {
            
                //Copy the data value into the JSON
                json.features[j].properties.value = dataValue;
                
                //Stop looking through the JSON
                break;
        
              }
            }		

          }
				
				//Bind data and create one path per GeoJSON feature
				map.selectAll("path")
				   .data(json.features)
				   .enter()
				   .append("path")
				   .attr("d", path)
           .style("fill", function(d) {
					   		//Get data value
					   		var value = d.properties.value;
					   		
					   		if (value) {
					   			//If value exists…
						   		return color(value);
					   		} else {
					   			//If value is undefined…
						   		return "#ccc";
					   		}
					   });

        d3.csv('./us-cities.csv', function(data){
          console.log(data);
          svg.selectAll("circle")
						   .data(data)
						   .enter()
						   .append("circle")
						   .attr("cx", function(d) {
							   return projection([d.lon,d.lat])[0];
						   })
						   .attr("cy", function(d) {
							   return projection([d.lon,d.lat])[1];
						   })
						   .attr("r", function(d) {
								return Math.sqrt(parseInt(d.population) * 0.00004);
						   })
						   .style("fill", "yellow")
						   .style("stroke", "gray")
						   .style("stroke-width", 0.25)
						   .style("opacity", 0.75)
						   .append("title")			//Simple tooltip
						   .text(function(d) {
								return d.place + ": Pop. " + formatAsThousands(d.population);
						   });
               
              });
             
		
			});

    });
  


   
    </script>
</body>
</html>